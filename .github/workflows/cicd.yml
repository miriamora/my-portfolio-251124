name: Real world Docker build and push

##To use, confirm your deployment test server is ready and docker is installed and enabled. 
##update secrets with ssh key and test server hostname as needed

on:
 
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
    aws_region: us-east-1
    python_version: 3.11
    image_name: portcicd # keep same as repository name easy management
    ecr_registry: public.ecr.aws/m1y0v6d8
    ecr_repository: public.ecr.aws/m1y0v6d8/portcicd
    #ecr_repository: ${{vars.aws_repo_public}}

    dev_test_server_private_key: ${{secrets.AWSKEYPAIR_PRIVATE_KEY}} # set up dev_test_server before running deployment stage

    hostname: ${{secrets.HOSTNAME}}  # *****please update with public ip address/hostname at secrets*****
    host_username: ubuntu
    ssh_port: ${{secrets.SSH_PORT}}
    container_port: 80 #check Dockerfile to confirm application EXPOSE port
    external_port: 80  #update if needed and make sure external port is open at deployment/test server

    EKS_cluster_name: "Dev-Test"
    

jobs:
    build_scan_and_store_image:
        runs-on: ubuntu-latest

        steps:

            - name: checkout git repository
              uses: actions/checkout@v4

            - name: setup_python
              uses: actions/setup-python@v4
              with:
                python-version: ${{env.python_version}} ## or $python_version
            
            - name: install pytest
              run: |
                python -m pip install --upgrade pip
                pip install -r requirements.txt
                pip install pytest

            - name: unit testing - python code
            # added test_app.py file - this should be from developer in real life situation???
              run: |
                pytest    
           

            - name: set up AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                aws-region: ${{ env.aws_region }}
            
            - name: login to AWS
              id: login-ecr
              uses: aws-actions/amazon-ecr-login@v2

            - name: Log in to Docker Hub
            #only use if pushing to DockerHub
              uses: docker/login-action@v3
              with:
                username: ${{ secrets.DOCKER_HUB_USERNAME }}
                password: ${{ secrets.DOCKER_HUB_PASSWORD }}

            - name: build docker image (for Trivy scan and ECR push)
              uses: docker/build-push-action@v5
              with:
                context: .
                push: false # holding off on push until scan step (below) is done
                tags: |
                  ${{ secrets.DOCKER_HUB_USERNAME }}/${{env.image_name}}:${{ github.run_number }}

            - name: Run Trivy Image Scan
              uses: aquasecurity/trivy-action@0.20.0
              with:
                image-ref: ${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.image_name }}:${{ github.run_number }}
                format: table
                exit-code: 0    # 1 --> scan fails even if vulnerabilities exist; 0 --> scan passes even if vulnerabilities exists
                ignore-unfixed: true

            - name: build and push docker image (docker hub)
            #only use if pushing to DockerHub (see note in next step)
              uses: docker/build-push-action@v5
              with:
                context: .
                push: true
                tags: |
                  ${{ secrets.DOCKER_HUB_USERNAME }}/${{env.image_name}}:${{ github.run_number }}
                  ${{secrets.DOCKER_HUB_USERNAME }}/${{env.image_name}}

            ##deactivate docker login and build-push steps above, then activate this instead if only pushing to ECR
            # - name: build image
            #   run: docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/${{env.image_name}}:${{ github.run_number }} .
            
            - name: push to AWS ECR
              run: |
                aws ecr-public get-login-password \
                --region us-east-1 | docker login --username AWS \
                --password-stdin ${{env.ecr_registry}}
                docker tag ${{ secrets.DOCKER_HUB_USERNAME }}/${{env.image_name}}:${{ github.run_number }} ${{env.ecr_registry}}/${{env.image_name}}:${{ github.run_number }}
                docker tag ${{ secrets.DOCKER_HUB_USERNAME }}/${{env.image_name}}:${{ github.run_number }} ${{env.ecr_registry}}/${{env.image_name}}
                docker push ${{env.ecr_registry}}/${{env.image_name}}:${{ github.run_number }}
                docker push ${{env.ecr_registry}}/${{env.image_name}}

    deploy_to_dev_server: #for lightsail
        runs-on: ubuntu-latest
        needs: build_scan_and_store_image
    
        steps:

            - name: remove old images and containers
              uses: appleboy/ssh-action@v0.1.7
              with:
                host: ${{ env.hostname }}
                username: ${{ env.host_username }}
                key: ${{ env.dev_test_server_private_key }}
                port: ${{env.SSH_PORT}}
                script: |
                    docker rm -f $(docker ps -aq) || true
                    docker rmi -f $(docker images -aq) || echo ""  #same as using true above
                    

            - name: run latest image # can merge with previous step
              if: ${{ always()}}
              uses: appleboy/ssh-action@v0.1.7
              with:
                host: ${{ env.hostname }}
                username: ${{ env.host_username }}
                key: ${{ env.dev_test_server_private_key }}
                port: ${{env.SSH_PORT}}
                script: |
                    docker pull ${{env.ecr_registry}}/${{env.image_name}}:${{ github.run_number }}
                    docker run -d --name portcicd_app -p ${{env.external_port}}:${{env.container_port}} ${{env.ecr_registry}}/${{env.image_name}}:${{ github.run_number }} #**adjust and open port to meet requirement**

            - name: display app information
              run: |
                echo "New update - Your application is ready for testing at ***hostname/public_ip:external_port*** "  

    deploy_to_EKS:
      needs: build_scan_and_store_image
      runs-on: ubuntu-latest
      steps: 
        - name: checkout git repository
          uses: actions/checkout@v4

        - name: set up AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-region: ${{ env.aws_region }}

        - name: Setup Kubectl
          uses: azure/setup-kubectl@v3
          with:
            version: 'v1.29.0'

        - name: Update kubeconfig
          run: |
            aws eks update-kubeconfig --name ${{env.EKS_cluster_name}} --region ${{ env.aws_region }}

        - name: Deploy to EKS
          run: |
            kubectl set image deployment/portcicd-deployment portcicd=${{env.ecr_registry}}/${{env.image_name}}:${{ github.run_number }}
            kubectl rollout status deployment/portcicd-deployment 
            kubectl get pods -l app=portcicd


    deploy_to_ECS:
      needs: build_scan_and_store_image
      runs-on: ubuntu-latest
      steps: 
        - name: checkout git repository
          uses: actions/checkout@v4

        - name: set up AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-region: ${{ env.aws_region }}

        - name: Update ECS Service
          run: |
            aws ecs update-service \
              --cluster ecs-cluster \
              --service service \
              --force-new-deployment \
              --region ${{env.aws_region}}





            
    
        
